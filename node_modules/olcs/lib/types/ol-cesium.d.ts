/// <reference path="olcs/FeatureConverter.d.ts" />
/// <reference types="cesium" />
import { default as AbstractSynchronizer } from './olcs/AbstractSynchronizer';
import { default as RasterSynchronizer } from './olcs/RasterSynchronizer';
import { default as VectorSynchronizer } from './olcs/VectorSynchronizer';
import * as core from './olcs/core';
import { default as OLImageryProvider } from './olcs/core/OLImageryProvider';
import { default as VectorLayerCounterpart } from './olcs/core/VectorLayerCounterpart';
import { default as ContribManager } from './olcs/contrib/Manager';
import { default as ContribLazyLoader } from './olcs/contrib/LazyLoader';
import OLCesium from './olcs';
declare const olcs: {
    AbstractSynchronizer: typeof AbstractSynchronizer;
    OLCesium: typeof OLCesium;
    RasterSynchronizer: typeof RasterSynchronizer;
    VectorSynchronizer: typeof VectorSynchronizer;
    OLImageryProvider: typeof OLImageryProvider;
    core: {
        OLImageryProvider: typeof OLImageryProvider;
        VectorLayerCounterpart: typeof VectorLayerCounterpart;
        computePixelSizeAtCoordinate(scene: import("cesium").Scene, target: import("cesium").Cartesian3): import("cesium").Cartesian2;
        computeBoundingBoxAtTarget(scene: import("cesium").Scene, target: import("cesium").Cartesian3, amount: number): import("cesium").Cartographic[];
        applyHeightOffsetToGeometry(geometry: import("ol/geom/Geometry").default, height: number): void;
        createMatrixAtCoordinates(coordinates: import("ol/coordinate").Coordinate, rotation?: number, translation?: import("cesium").Cartesian3, scale?: import("cesium").Cartesian3): import("cesium").Matrix4;
        rotateAroundAxis(camera: import("cesium").Camera, angle: number, axis: import("cesium").Cartesian3, transform: import("cesium").Matrix4, opt_options?: {
            duration?: number;
            easing?: (value: number) => number;
            callback: () => void;
        }): void;
        setHeadingUsingBottomCenter(scene: import("cesium").Scene, heading: number, bottomCenter: import("cesium").Cartesian3, options?: {
            duration?: number;
            easing?: (value: number) => number;
            callback: () => void;
        }): void;
        pickOnTerrainOrEllipsoid(scene: import("cesium").Scene, pixel: import("cesium").Cartesian2): import("cesium").Cartesian3;
        pickBottomPoint(scene: import("cesium").Scene): import("cesium").Cartesian3;
        pickCenterPoint(scene: import("cesium").Scene): import("cesium").Cartesian3;
        computeSignedTiltAngleOnGlobe(scene: import("cesium").Scene): number;
        bottomFovRay(scene: import("cesium").Scene): import("cesium").Ray;
        signedAngleBetween(first: import("cesium").Cartesian3, second: import("cesium").Cartesian3, normal: import("cesium").Cartesian3): number;
        computeAngleToZenith(scene: import("cesium").Scene, pivot: import("cesium").Cartesian3): number;
        extentToRectangle(extent: import("ol/extent").Extent, projection: import("ol/proj").ProjectionLike): import("cesium").Rectangle;
        sourceToImageryProvider(olMap: import("ol/Map").default, source: import("ol/source/Source").default, viewProj: import("ol/proj/Projection").default, olLayer: import("ol/layer/Base").default): OLImageryProvider | import("./olcs/MVTImageryProvider").default | import("cesium").SingleTileImageryProvider;
        tileLayerToImageryLayer(olMap: import("ol/Map").default, olLayer: import("ol/layer/Base").default, viewProj: import("ol/proj/Projection").default): import("cesium").ImageryLayer;
        updateCesiumLayerProperties(olLayerWithParents: core.LayerWithParents, csLayer: import("cesium").ImageryLayer): void;
        ol4326CoordinateToCesiumCartesian(coordinate: import("ol/coordinate").Coordinate): import("cesium").Cartesian3;
        ol4326CoordinateArrayToCsCartesians(coordinates: import("ol/coordinate").Coordinate[]): import("cesium").Cartesian3[];
        olGeometryCloneTo4326<T extends import("ol/geom/Geometry").default>(geometry: T, projection: import("ol/proj").ProjectionLike): T;
        convertColorToCesium(olColor: string | import("ol/color").Color | CanvasPattern | CanvasGradient): import("cesium").Color | import("cesium").ImageMaterialProperty;
        convertUrlToCesium(url: string): {
            url: string;
            subdomains: string;
        };
        resetToNorthZenith(map: import("ol/Map").default, scene: import("cesium").Scene): Promise<undefined>;
        rotateAroundBottomCenter(scene: import("cesium").Scene, angle: number): Promise<undefined>;
        normalizeView(view: import("ol/View").default, angle?: number): void;
        isCesiumProjection(projection: import("ol/proj/Projection").default): boolean;
        attributionsFunctionToCredits(attributionsFunction: import("ol/source/Source").Attribution, zoom: number, center: import("ol/coordinate").Coordinate, extent: import("ol/extent").Extent): import("cesium").Credit[];
        calcDistanceForResolution(resolution: number, latitude: number, scene: import("cesium").Scene, projection: import("ol/proj/Projection").default): number;
        calcResolutionForDistance(distance: number, latitude: number, scene: import("cesium").Scene, projection: import("ol/proj/Projection").default): number;
        limitCameraToBoundingSphere(camera: import("cesium").Camera, boundingSphere: import("cesium").BoundingSphere, ratio: (height: number) => number): () => void;
    };
    contrib: {
        LazyLoader: typeof ContribLazyLoader;
        Manager: typeof ContribManager;
    };
};
declare global {
    interface Window {
        olcs: typeof olcs;
    }
}
export {};
//# sourceMappingURL=ol-cesium.d.ts.map